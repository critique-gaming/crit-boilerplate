local progression = require "crit.progression"
local env = require "crit.env"
local monarch = require "monarch.monarch"

local game = require "main.progression.game"

local h_run_progression = hash("run_progression")

-- Define your progressions here. They are coroutines which optionally recieve an argument.
-- By default the `main` coroutine is ran, unless overriden by `env.entry_progression`.
-- To cancel the currently running progression and start a new one, do
-- `dispatcher.dispatch(h_run_progression, { id = "my_progression", options = "the_optional_arg" })`
local progressions = {
  main = function ()
    if env.entry_screen then
      monarch.show(env.entry_screen, nil, env.entry_screen_data)
      return
    end

    game()
  end,

  game = game,
}

local function run_progression(progression_id, ...)
  -- The first argument is normally a progression id, but also accept
  -- a function which could come from env.entry_progression
  local coroutine_function
  if type(progression_id) == 'function' then
    coroutine_function = progression_id
  else
    coroutine_function = progressions[progression_id]
  end

  if not coroutine_function then
    print("ERROR: There is no progression with id \"" .. progression_id .. "\"")
    return
  end
  return progression.detach(coroutine_function, ...)
end

local function entry_point()
  local co

  local watcher = progression.fork(function ()
    while true do
      local message = progression.wait_for_message(h_run_progression)
      if co then progression.cancel(co) end
      co = run_progression(message.id, message.options)
    end
  end)

  co = run_progression(env.entry_progression or "main", env.entry_progression_arg)
  progression.join(watcher)
end

progression.init_register_function(entry_point)
